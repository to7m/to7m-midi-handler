from ._specs import SPECS_FOR_SPEC_NAMES


_SPEC_NAMES_FOR_PARAM_NAMES = {
    "nested": "nested",
    "lcp_i": "uint8",
    "pslot_i": "uint8",
    "timestamp_ns": "uint64"
    "midi_note": "uint8",
    "true_vel": "true_vel"
}

_SPECS_FOR_PARAM_NAMES = {
    param_name: SPECS_FOR_SPEC_NAMES[spec_name]
    for param_name, spec_name in _SPEC_NAMES_FOR_PARAM_NAMES.items()
}


class Param:
    def __init__(self, name, spec=None):
        self.name = name

        spec = self._determine_spec(name, spec)
        spec_str = f"{spec.__module__}.{spec.__qualname__}"
        self.init_lines = [
            f"# generated by {spec_str}.get_init_lines()"
            *spec.get_init_lines(name)
        ]
        self.write_lines = [
            f"# generated by {spec_str}.get_write_lines()"
            *spec.get_write_lines(name)
        ]
        self.read_lines = [
            f"# generated by {spec_str}.get_read_lines()"
            *spec.get_read_lines(name)
        ]

    def _determine_spec(self, name, spec):
        if spec is None:
            if name in _SPECS_FOR_PARAM_NAMES:
                return _SPECS_FOR_PARAM_NAMES[name]
            else:
                raise KeyError(
                    f"no spec provided or found for param name {name!r}"
                )
        elif isinstance(spec, Spec):
            return spec
        elif type(spec) is str:
            if spec in SPECS_FOR_SPEC_NAMES:
                return SPECS_FOR_SPEC_NAMES[spec]
            else:
                raise KeyError(f"no spec found for spec name {spec!r}")
        else:
            raise TypeError(
                "spec should be either None, a Spec instance, or a str"
            )


class Params:
    def __init__(self, *, _data=None):
        if _data is None:
            raise Exception(
                "Params should be instantiated via constructor methods"
            )
        else:
            self._data = _data

    def __bool__(self):
        return bool(self._data)

    def __getitem__(self, key):
        return self._data[key]

    @classmethod
    def from_list(cls, args_list):
        args_tuples = []
        for x in args_list:
            if type(x) is tuple:
                args_tuples.append(x)
            else:
                args_tuples.append((x,))

        return cls([Param(*args_tuple) for args_tuple in args_tuples])

    @classmethod
    def from_dict(cls, names_and_specs):
        return cls.from_list(list(names_and_specs.items()))


def sanitise_params(params):
    if params is None:
        return Params.from_list([])
    elif type(params) is list:
        return Params.from_list(params)
    elif type(params) is dict:
        return Params.from_dict(params)
    elif type(params) is Params:
        return params
    else:
        raise Exception(
            "if provided, params should be a list, dict, or Params instance"
        )
